{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Bootcamp","text":"<p>This site contains the materials for Ka\u02bbimi's (very) opinionated software developer bootcamp. This bootcamp will cover a large variety of concepts neccessary to succeed as a data/analytics-oriented software developer. </p>"},{"location":"#structure-of-the-bootcamp","title":"Structure of the bootcamp:","text":"<ul> <li>Related content has been grouped into modules.<ul> <li>Each module spans at least one week (some are longer/shorter than others).<ul> <li>Each week will have two sessions, each discussing a primary concept.<ul> <li>Each session will be followed by recommended \"homework\" to apply the concepts discussed.</li> <li>Furthermore, recommended additional materials will be made available.</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"module-1/","title":"Module 1: Foundational Tools &amp; Environment","text":"<p>This module is designed to get students set up with the essential tools for collaborative and reproducible software development. They will master Git and GitHub, learn to use Visual Studio Code, and then dive into the world of containers with Docker, Docker Compose, and DevContainers.</p>"},{"location":"module-1/#week-1-git-github-and-visual-studio-code","title":"Week 1: Git, GitHub, and Visual Studio Code","text":"<p>Session 1: Git &amp; GitHub Essentials \ud83d\udcbb This session covers the fundamentals of version control. Students will learn core Git commands like init, add, commit, and status. We'll also cover the collaborative aspects of GitHub, including push, pull, and the concept of a pull request.</p> <p>Session 2: Visual Studio Code Mastery \u270d\ufe0f Students will be introduced to Visual Studio Code (VS Code), our primary development environment for the bootcamp. We'll explore its user interface, essential shortcuts, and key extensions. The goal is for students to become comfortable and efficient with the editor.</p>"},{"location":"module-1/#week-2-docker-docker-compose-and-devcontainers","title":"Week 2: Docker, Docker Compose, and DevContainers","text":"<p>Session 1: Docker Fundamentals \ud83d\udc33 This session introduces Docker, explaining the difference between containers and virtual machines. Students will write their first Dockerfile to containerize a simple Python application.</p> <p>Session 2: Orchestration &amp; Reproducible Environments \u2699\ufe0f Building on the first session, we'll introduce Docker Compose to manage multi-service applications (e.g., a web app and a database). The session will culminate in setting up DevContainers for our course, ensuring every student has an identical, reproducible development environment from this point on.</p>"},{"location":"module-1/week-1/","title":"Week 1: Git, GitHub, and Visual Studio Code","text":"<p>Session 1: Git &amp; GitHub Essentials \ud83d\udcbb This session covers the fundamentals of version control. Students will learn core Git commands like init, add, commit, and status. We'll also cover the collaborative aspects of GitHub, including push, pull, and the concept of a pull request.</p> <p>Session 2: Visual Studio Code Mastery \u270d\ufe0f Students will be introduced to Visual Studio Code (VS Code), our primary development environment for the bootcamp. We'll explore its user interface, essential shortcuts, and key extensions. The goal is for students to become comfortable and efficient with the editor.</p>"},{"location":"module-1/week-1/session-1/","title":"Session 1: Git &amp; GitHub Essentials \ud83d\udcbb","text":"<p>Welcome to the first session of our software development bootcamp! Today, we're diving into the world of Git and GitHub, essential tools for any modern developer. We'll be focusing on using the GitHub Desktop application, which provides a user-friendly graphical interface for managing your code.</p>"},{"location":"module-1/week-1/session-1/#introduction-to-version-control","title":"Introduction to Version Control","text":"<p>Imagine you're writing a really important document. You save it, then make some changes, and save it again. What if you want to go back to an earlier version? Or what if you're working with a team, and everyone is making changes at the same time? This is where Version Control Systems (VCS) come in!</p> <p>Git is the most popular distributed version control system. It helps you:</p> <ul> <li>Track changes to your code over time.</li> <li>Revert to previous versions if something goes wrong.</li> <li>Collaborate with other developers without overwriting each other's work.</li> </ul> <p>A repository (often shortened to \"repo\") is simply a project folder that Git is tracking.</p>"},{"location":"module-1/week-1/session-1/#getting-started-with-github-desktop","title":"Getting Started with GitHub Desktop","text":"<p>Other Options</p> <p>There are numerous other options for working with git-like tools, besides GitHub Desktop (such as using the git CLI directly). However, I find that GitHub Desktop covers all we need and is far more beginner friendly.</p> <p>Before we dive into Git concepts, let's get you set up with the tool we'll be using: GitHub Desktop.</p> <p>Installation and Sign-In:</p> <ol> <li>Download GitHub Desktop: If you haven't already, go to GitHub Desktop and download the application for your operating system.</li> <li>Install: Follow the on-screen instructions to install GitHub Desktop.</li> <li>Sign In: When you open GitHub Desktop for the first time, you'll be prompted to sign in with your GitHub account. If you don't have one, you'll need to create one on github.com first. This links your local GitHub Desktop application to your online GitHub profile.</li> </ol>"},{"location":"module-1/week-1/session-1/#basic-git-concepts-illustrated-with-github-desktop-in-mind","title":"Basic Git Concepts (Illustrated with GitHub Desktop in Mind)","text":"<p>Let's look at the core ideas behind Git that GitHub Desktop helps you manage.</p>"},{"location":"module-1/week-1/session-1/#commits-snapshots-of-your-work","title":"Commits: Snapshots of Your Work","text":"<p>Think of a commit as a snapshot of your project at a specific point in time. Every time you save a set of related changes, you create a commit. Each commit has a unique ID, a message describing the changes, and information about who made the commit and when.</p> <pre><code>graph LR\n    A[Start Project] --&gt; B{Add File 1};\n    B --&gt; C(Commit 'Initial commit');\n    C --&gt; D{Modify File 1};\n    D --&gt; E(Commit 'Update File 1 content');\n    E --&gt; F{Add File 2};\n    F --&gt; G(Commit 'Add new feature');</code></pre> <p>In GitHub Desktop, the \"Changes\" tab shows you what files you've modified. Once you've selected the changes you want to save, you'll write a commit message and click \"Commit to [Branch Name]\".</p> <p>Making good commit messages</p> <p>At the bare minimum, a commit message must descriptive enough to describe the change. However, there is a standard called Coventional Commits which describes a standard structure which promotes good practices. See HERE for a useful cheatsheet which I personally reference often.</p>"},{"location":"module-1/week-1/session-1/#branches-parallel-lines-of-development","title":"Branches: Parallel Lines of Development","text":"<p>Branches allow you to work on new features or bug fixes without affecting the main version of your project. Imagine the \"main\" branch as your stable, working code. When you start a new feature, you create a new branch from <code>main</code>, work on it independently, and then merge it back when it's ready.</p> <pre><code>gitGraph\n    commit id: \"Initial commit\"\n    branch feature-A\n    commit id: \"Work on Feature A\"\n    checkout main\n    branch feature-B\n    commit id: \"Work on Feature B\"\n    checkout main\n    merge feature-A id: \"Merge Feature A\"\n    checkout feature-B\n    commit id: \"More work on Feature B\"\n    checkout main\n    merge feature-B id: \"Merge Feature B\"</code></pre> <p>In GitHub Desktop, you can easily create new branches, switch between them, and see which branch you're currently on using the \"Current Branch\" dropdown.</p> <p>Keep branches purposeful</p> <p>When building software, it's always good to build things in small pieces, rather than chasing perfection in one commit. When building (or maintaining) software, it's generally good practice that each new feature (or bug fix, etc.) is placed on a new branch, and then merged when it's \"good enough\" to join the <code>main</code> branch.</p>"},{"location":"module-1/week-1/session-1/#the-general-software-development-cycle-with-github","title":"The General Software Development Cycle with GitHub","text":"<p>Here's a typical workflow you'll follow when developing software with Git and GitHub:</p> <ol> <li>Clone a Repository: Get a copy of the project's code onto your local machine.</li> <li>Create a New Branch: Start working on a new feature or fix in isolation.</li> <li>Make Changes &amp; Commit: Write code, save changes, and create commits to record your progress.</li> <li>Push Changes: Upload your local commits to the remote GitHub repository.</li> <li>Create a Pull Request (PR): Propose your changes to be reviewed and merged into the <code>main</code> branch.</li> <li>Review &amp; Discuss: Other team members review your code, suggest improvements, and engage in discussions.</li> <li>Merge: Once approved, your changes are integrated into the <code>main</code> branch.</li> <li>Pull Changes: Update your local repository with the latest changes from the <code>main</code> branch.</li> </ol> <p>Here's a visual representation of this cycle:</p> <pre><code>graph TD\n    A0[Clone/Create Repo]\n    A0 --&gt; A[Start New Feature/Bug Fix]\n    A --&gt; B(Create New Branch);\n    B --&gt; C{Make Changes &amp; Commit};\n    C --&gt; D(Push Branch to GitHub);\n    D --&gt; E(Create Pull Request - PR);\n    E -- Feedback/Changes Required --&gt; C;\n    E -- Approved --&gt; F(Merge PR into Main);\n    F --&gt; G(Delete Feature Branch);\n    G --&gt; H[Pull Latest Main to Local];\n    H --&gt; A;</code></pre>"},{"location":"module-1/week-1/session-1/#essential-github-desktop-operations-live-demo-focus","title":"Essential GitHub Desktop Operations (Live Demo Focus)","text":"<p>We'll demonstrate these steps live using GitHub Desktop. Pay close attention to the interface elements!</p>"},{"location":"module-1/week-1/session-1/#cloning-a-repository","title":"Cloning a Repository","text":"<ul> <li>Purpose: To get a copy of an existing GitHub repository onto your computer.</li> <li>GitHub Desktop Steps:<ul> <li>Click \"File\" &gt; \"Clone Repository\".</li> <li>Select the repository from your GitHub.com account, or use the URL if it's a public repository.</li> <li>Choose a local path where you want to save the repository.</li> <li>Click \"Clone\".</li> </ul> </li> </ul>"},{"location":"module-1/week-1/session-1/#making-changes-committing","title":"Making Changes &amp; Committing","text":"<ul> <li>Purpose: To save a snapshot of your work.</li> <li>GitHub Desktop Steps:<ul> <li>Open the cloned repository folder in your favorite code editor (like VS Code, which we'll cover in Session 2!).</li> <li>Make some changes to a file, or create a new file.</li> <li>Go back to GitHub Desktop. You'll see your modified files listed in the \"Changes\" tab.</li> <li>Staging (Implied in Desktop): In GitHub Desktop, simply checking the box next to a file stages it for the next commit. You can select which changes you want to include.</li> <li>Write a clear and concise Summary (the commit message title) and optionally a Description.</li> <li>Click \"Commit to [current branch name]\".</li> </ul> </li> </ul>"},{"location":"module-1/week-1/session-1/#branching","title":"Branching","text":"<ul> <li>Purpose: To create an isolated environment for new work.</li> <li>GitHub Desktop Steps:<ul> <li>From the \"Current Branch\" dropdown at the top of the interface, click \"New Branch\".</li> <li>Give your branch a descriptive name (e.g., add-contact-form, fix-login-bug).</li> <li>Click \"Create Branch\". GitHub Desktop will automatically switch you to this new branch.</li> </ul> </li> </ul>"},{"location":"module-1/week-1/session-1/#pushing-changes","title":"Pushing Changes","text":"<ul> <li>Purpose: To upload your local commits to the remote GitHub repository.</li> <li>GitHub Desktop Steps:<ul> <li>After making commits on your local branch, a \"Publish Branch\" button (for a new branch) or \"Push origin\" button (for an existing remote branch) will appear at the top.</li> <li>Click this button. Your commits will now be visible on GitHub.com.</li> </ul> </li> </ul>"},{"location":"module-1/week-1/session-1/#submitting-a-pull-request-pr","title":"Submitting a Pull Request (PR)","text":"<ul> <li>Purpose: To propose your changes from your branch to be merged into another branch (usually <code>main</code>). This is where code review happens.</li> <li>GitHub Desktop Steps:<ul> <li>After pushing your branch, GitHub Desktop will often show a prompt to \"Create Pull Request\".</li> <li>Clicking this will take you to GitHub.com, pre-filling much of the PR information.</li> <li>Review: On GitHub.com, you can then add reviewers, describe your changes, and initiate the review process.</li> <li>Reviewing a PR: If someone else creates a PR, you can view the changes, add comments, and approve or request changes directly on GitHub.com.</li> </ul> </li> </ul>"},{"location":"module-1/week-1/session-1/#git-github-best-practices-dos-and-donts","title":"Git &amp; GitHub Best Practices: Dos and Don'ts \u2705\u274c","text":"<p>To make your Git and GitHub experience smooth and collaborative, keep these best practices in mind:</p>"},{"location":"module-1/week-1/session-1/#dos","title":"\u2705 Do's:","text":"<ul> <li> Do commit early and often: Make small, focused commits. Each commit should represent a single logical change. This makes it easier to track progress and revert changes if needed.</li> </ul> <p>Making good commit messages</p> <p>At the bare minimum, a commit message must descriptive enough to describe the change. However, there is a standard called Coventional Commits which describes a standard structure which promotes good practices. See HERE for a useful cheatsheet which I personally reference often.</p> <ul> <li> Do write clear, concise commit messages: Your commit message should briefly explain what you changed and why. A good message tells a story. </li> <li> Do use branches for new features/fixes: Always work on a new branch, not directly on <code>main</code>. This keeps <code>main</code> stable and allows for isolated development.</li> <li> Do pull frequently: Regularly pull changes from the <code>main</code> branch to keep your local repository up-to-date and minimize merge conflicts.</li> <li> Do review Pull Requests thoroughly: When reviewing others' code, provide constructive feedback and ask clarifying questions.</li> </ul>"},{"location":"module-1/week-1/session-1/#donts","title":"\u274c Don'ts:","text":"<p>Data Should be Ephemeral</p> <p>In general, when data is generated programmatically, rather than worrying about saving/archiving the data, it's best to make sure the data can be regenerted easily programmatically. There are some exceptions when data gets larger (and expensive to recompute), however the general concept applies.</p> <ul> <li> Don't commit large data files or binaries: Git is designed for tracking text-based code. Large files like images, videos, or <code>.csv</code> files should generally not be committed directly to Git. Use services like Git LFS (Large File Storage) or external storage solutions for these.</li> <li> Don't commit sensitive information: Never commit API keys, passwords, private keys, or other sensitive credentials directly into your repository. Use environment variables or secure configuration management.</li> <li> Don't force push to shared branches: \"Force pushing\" rewrites commit history. While sometimes necessary on personal branches, it can cause major issues on shared branches like <code>main</code> as it deletes other people's work.</li> </ul> <p>Good Starting Points</p> <p>The community has curated useful <code>.gitignore</code> templates for a variety of projects which you can start from https://github.com/github/gitignore. Furthermore, when creating a new repo with GitHub Desktop, it may even prompt you to start with a suggested .gitignore. </p> <ul> <li> Don't ignore <code>.gitignore</code>: Use a <code>.gitignore</code> file to tell Git which files and directories to ignore (e.g., <code>__pycache__</code>, virtual environments, logs, temporary/sensitive files). This keeps your repository clean.</li> <li> Don't commit commented-out code: If code isn't needed, delete it. Git history preserves it if you ever need to retrieve </li> </ul>"},{"location":"module-1/week-1/session-1/#optional-practice-further-reading","title":"Optional Practice &amp; Further Reading","text":"<p>To really solidify your understanding, try these exercises and explore the suggested resources. By the start of our next session, you should feel comfortable cloning or creating a repository and contributing to it using GitHub Desktop.</p>"},{"location":"module-1/week-1/session-1/#optional-practice-exercises","title":"Optional Practice Exercises:","text":""},{"location":"module-1/week-1/session-1/#create-your-first-repository","title":"Create Your First Repository:","text":"<ul> <li>In GitHub Desktop, go to File &gt; New Repository.</li> <li>Give it a meaningful name (e.g., <code>my-first-git-repo</code>).</li> <li>Initialize it with a <code>README.md</code> file.</li> <li>Make a simple change to the <code>README.md</code> file (e.g., add your name), commit it, and push it to GitHub.com.</li> </ul>"},{"location":"module-1/week-1/session-1/#clone-a-sample-project","title":"Clone a Sample Project:","text":"<ul> <li>Find a small, open-source project on GitHub (you can search for \"beginner python projects\" or \"hello world repository\").</li> <li>Use GitHub Desktop to clone this repository to your local machine.</li> <li>Make a small, non-breaking change (e.g., fix a typo in a comment, add your name to a CONTRIBUTORS file if one exists).</li> <li>Create a new branch for your change.</li> <li>Commit your change on this new branch.</li> <li>Push your branch to GitHub.</li> <li>Create a pull request (you don't need it to be merged, just demonstrate you can create one).</li> </ul>"},{"location":"module-1/week-1/session-1/#branching-practice","title":"Branching Practice:","text":"<ul> <li>In one of your local repositories, create three new branches: <code>feature-a</code>, <code>feature-b</code>, and <code>bugfix-c</code>.</li> <li>On <code>feature-a</code>, make one commit.</li> <li>Switch to <code>feature-b</code>, make a different commit.</li> <li>Switch to <code>bugfix-c</code>, make another commit.</li> <li>Push all three branches to GitHub.</li> <li>Try merging <code>feature-a</code> into <code>main</code> (if you feel comfortable, or just observe the merge in GitHub Desktop).</li> </ul>"},{"location":"module-1/week-1/session-1/#next-steps-questions","title":"Next Steps &amp; Questions","text":"<p>We've covered a lot today! The key takeaway is that GitHub Desktop simplifies these powerful Git concepts into a visual workflow. Practice these operations, and don't hesitate to ask questions.</p>"},{"location":"module-1/week-2/","title":"Week 2: Docker, Docker Compose, and DevContainers","text":"<p>Session 1: Docker Fundamentals \ud83d\udc33 This session introduces Docker, explaining the difference between containers and virtual machines. Students will write their first Dockerfile to containerize a simple Python application.</p> <p>Session 2: Orchestration &amp; Reproducible Environments \u2699\ufe0f Building on the first session, we'll introduce Docker Compose to manage multi-service applications (e.g., a web app and a database). The session will culminate in setting up DevContainers for our course, ensuring every student has an identical, reproducible development environment from this point on.</p>"},{"location":"module-2/","title":"Module 2: Advanced Python","text":"<p>This module focuses on writing clean, professional-grade Python code and introduces the fundamental concepts of data engineering.</p>"},{"location":"module-2/#week-3-advanced-python-unit-testing","title":"Week 3: Advanced Python &amp; Unit Testing","text":"<p>Session 1: With our environment ready in a DevContainer, We'll explore advanced Python features that lead to cleaner, more maintainable code. Topics include type hints for improved static analysis, writing clear docstrings, and using Pydantic for robust data validation.</p> <p>Session 2: This session is a deep dive into functional code design. We'll discuss how to organize code into reusable modules and classes. We'll also cover concepts like pure functions and higher-order functions and show how to apply them to build elegant and predictable code. We will also discuss object-oriented design patterns.</p>"},{"location":"module-2/#week-4-unit-testing-and-validation","title":"Week 4: Unit Testing and Validation","text":"<p>Session 1: This session is all about writing high-quality, testable code. We'll introduce unit testing and practice writing tests for a Python application using the pytest framework. We'll emphasize the principles of test-driven development (TDD) to build features that are robust from the start.</p> <p>Session 2: We'll focus on data validation and error handling. Students will learn how to write tests that specifically challenge Pydantic models to ensure that incoming data is always correctly formatted. We'll also cover best practices for creating custom validation logic.</p>"},{"location":"module-3/","title":"Module 3: Data Engineering &amp; Distributed Systems","text":""},{"location":"module-3/#week-5-data-engineering-fundamentals","title":"Week 5: Data Engineering Fundamentals \ud83d\udcca","text":"<p>Session 1: This session introduces core data engineering concepts. We'll discuss the differences between ETL (Extract, Transform, Load) and ELT (Extract, Load, Transform) and explore their modern applications in data pipelines.</p> <p>Session 2: We'll introduce the Data Medallion Architecture , a foundational pattern for building reliable data lakes. We'll explain the purpose of each layer (Bronze, Silver, Gold) and discuss how data flows through them.</p>"},{"location":"module-3/#week-6-databricks-pyspark","title":"Week 6: Databricks &amp; PySpark \ud83d\udcc8","text":"<p>Session 1: We'll introduce Databricks as a platform for large-scale data processing. We'll explore the basics of Apache Spark and how it distributes data processing across a cluster.</p> <p>Session 2: This is a hands-on session with PySpark. Students will learn to work with Spark DataFrames and perform common data manipulation operations like filter, select, and groupby in a distributed environment.</p>"},{"location":"module-3/#week-7-spark-sql-and-data-pipelines","title":"Week 7: Spark SQL and Data Pipelines","text":"<p>Session 1: SQL basics. Students will write queries in Databricks to join tables, perform aggregations, and transform data.</p> <p>Session 2: Building a simple data pipeline. Students will apply their knowledge to move and transform data between the medallion layers within Databricks using either PySpark or Spark SQL.</p>"},{"location":"module-4/","title":"Module 3: Architecture Design","text":""},{"location":"module-4/#week-8-introduction-to-apis","title":"Week 8: Introduction to APIs","text":"<p>Session 1: Concepts of APIs (REST, GraphQL, gRPC, etc.)</p> <p>Session 2: We'll introduce the FastAPI framework, a modern web framework for building APIs. Building on our advanced Python skills, we'll design and create our first API endpoints.</p>"},{"location":"module-4/#week-9-architecture-design-patterns","title":"Week 9: Architecture Design Patterns","text":"<p>Session 1: We'll explore different system architectures, comparing the benefits and drawbacks of monolithic vs. microservice designs.</p> <p>Session 2: This session covers the principles of event-driven vs. message-driven architectures. We'll discuss how asynchronous communication through message queues can help build scalable and decoupled systems.</p>"},{"location":"module-5/","title":"Module 5: Capstone","text":""}]}